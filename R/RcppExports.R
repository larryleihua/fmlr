# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' exponentially weighted moving average; only return the last value
#' @param x a numeric vector
#' @param n window size
#' 
#' @return a numeric value
#' 
#' @author Larry Lei Hua
#' 
#' @export
ema <- function(x, n) {
    .Call(`_fmlr_ema`, x, n)
}

#' Tstar index for Tick Runs Bars (bar_trb)
#' @param b_t output of imbalance_tick(dat) with the dat has at least the following columns: Price
#' @param w0 the expected time window length of the first bar
#' @param de a positive value for adjusting the expected window size, that is, de*E0
#' @param bkw_T backward window length for exponentially weighted average T
#' @param bkw_Pb1 backward window length for exponentially weighted average P[b_t=1]
#' 
#' @return a list of the following two vectors: 
#'     a vector for the lengths of the tick imbalance bars. For example, if the return is c(10,26), then the 2 tick imbalance bars are (0,10] and (10, 36]
#'     a vector indicating up runs or down runs
#' 
#' @examples
#' 
#' set.seed(1)
#' dat <- data.frame(Price = c(rep(0.5, 5), runif(100)))
#' b_t <- imbalance_tick(dat)
#' T_trb <- Tstar_trb_cpp(b_t, 10, 1.0, 10, 10)
#' col <- ifelse(T_trb$Type==1, "red", "blue")
#' T <- cumsum(T_trb$Tstar)
#' plot(dat$Price)
#' for(i in 1:length(T)) abline(v = T[i], col = col[i])
#'  
#' @export
Tstar_trb_cpp <- function(b_t, w0, de, bkw_T, bkw_Pb1) {
    .Call(`_fmlr_Tstar_trb_cpp`, b_t, w0, de, bkw_T, bkw_Pb1)
}

#' Tstar index for Volume Runs Bars (bar_vrb)
#' @param b_t output of imbalance_tick(dat) with the data 'dat' has at least the following columns: Price
#' @param v_t volume of the same data
#' @param v_0 average volume for each trade, and it is used to create the first bar
#' @param w0 the expected time window length of the first bar
#' @param de a positive value for adjusting the expected window size, that is, de*E0T; default: 1.
#' @param bkw_T backward window length for exponentially weighted average T
#' @param bkw_Pb1 backward window length for exponentially weighted average P[b_t=1]
#' @param bkw_V backward window length for exponentially weighted average volumes
#' 
#' @return a list of the following two vectors: 
#'     a vector for the lengths of the tick imbalance bars. For example, if the return is c(10,26), then the 2 tick imbalance bars are (0,10] and (10, 36]
#'     a vector indicating up runs or down runs
#' 
#' @examples
#' 
#' set.seed(1)
#' dat <- data.frame(Price = c(rep(0.5, 5), runif(100)), Size = runif(105, 10, 100))
#' b_t <- imbalance_tick(dat)
#' v_t <- dat$Size
#' T_vrb <- Tstar_vrb_cpp(b_t, v_t, 55, 10, 1.0, 10, 10, 10)
#' col <- ifelse(T_vrb$Type==1, "red", "blue")
#' T <- cumsum(T_vrb$Tstar)
#' plot(dat$Price)
#' for(i in 1:length(T)) abline(v = T[i], col = col[i])
#'  
#' @export
#' 
Tstar_vrb_cpp <- function(b_t, v_t, v_0, w0, de, bkw_T, bkw_Pb1, bkw_V) {
    .Call(`_fmlr_Tstar_vrb_cpp`, b_t, v_t, v_0, w0, de, bkw_T, bkw_Pb1, bkw_V)
}

#' time index that triggers a symmetric CUSUM filter
#'
#' @param x a vector of time series to be filtered
#' @param h a vector of the thresholds
#'
#' @examples
#' set.seed(1)
#' x <- runif(100, 1, 3)
#' h <- rep(1.5, 100)
#' i_CUSUM <- istar_CUSUM(x,h)
#' abline(v=i_CUSUM, lty = 2)
#'
#' ## Comparing C and R versions
#' # set.seed(1)
#' # x <- runif(1000000, 1, 3)
#' # h <- rep(1.5, 100)
#'
#' # start_time <- Sys.time()
#' # i_CUSUM <- istar_CUSUM(x,h)
#' # end_time <- Sys.time()
#' # C_time <- end_time - start_time
#'
#' # start_time <- Sys.time()
#' # i_CUSUM_R <- istar_CUSUM_R(x,h)
#' # end_time <- Sys.time()
#' # R_time <- end_time - start_time
#' # cat("C and R time: ", C_time, R_time)
#' # all(i_CUSUM-i_CUSUM_R==0)
#' 
#' @author Larry Lei Hua
#' 
#' @export
istar_CUSUM <- function(x, h) {
    .Call(`_fmlr_istar_CUSUM`, x, h)
}

